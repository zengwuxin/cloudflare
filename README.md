# Technical Assessment Report 
## 1. Add Domain to Cloudflare
I used an existing [website](https://wwww.nagoyasushiaz.com) that I created and hosted on GoDaddy. I removed GoDaddy's nameservers and changed them to Cloudflare's.  

## 2. Return HTTP Request Headers
I used HTTPBin to return request headers in the body of the response. To run HTTPBin locally, I ran `docker run -p 80:80 kennethreitz/httpbin`. Then I was able to use `curl nagoyasushiaz.com/headers` to retrieve information on the headers.
```
{
  "headers": {
    "Accept": "*/*", 
    "Host": "nagoyasushiaz.com", 
    "User-Agent": "curl/7.64.1"
  }
}
```

 

## 3. End-to-End Encryption 

*Note: The following step was performed before I found out that Cloudflare offers a Universal SSL certificate, generated by Let's Encrypt using EC key. This certificate is auto-renewed after three months. To enable secure communication between the visitor and Cloudflare and Cloudflare and my origin with TLS 1.2 or above, I selected TLS 1.3 on the SSL/TLS Edge Certificates page. Nevertheless, I still included the explanation below to show what I did initially to add a cert/key manually.*

Because GoDaddy does not support EC encriptyption nor certificates generated by Cloudflare, I used Let's Encrypt RSA key to generate the TLS certificate and key. Once I did that, I added them to my website through GoDaddy. Then I went back to Cloudflare dashboard and selected full encryption to set up end-to-end encryption, where the communication between the browser and Cloudflare is secured as well as the communication between Cloudflare and the origin server. 

##  4. Argo Tunnel 

To set up Argo tunnel, I first installed `cloudflared` on my machine. I authenticated to Cloudflare with `cloudflared tunnel login` and made sure I have a cert.pem file in my .cloudflared/ directory. Then I created a tunnel with `cloudflared tunnel create wuxin-tst` and the following config.yml. 
```
url: https://nagoyasushiaz.com
tunnel: 8ccb00c9-5b5f-43a4-af2c-ee2a97528220
credentials-file: /Users/angelinezeng/.cloudflared/8ccb00c9-5b5f-43a4-af2c-ee2a97528220.json
```
In the config.yml, I updated the URL to https://www.nagoyasushiaz.com and the UUID to use my tunnel's UUID. Then I routed the traffic to the tunnel with   `cloudflared tunnel route dns wuxin-tst nagoyasushiaz.com`. To start running the tunnel, I did `cloudflared tunnel run wuxin-tst`.

## 5. Cloudflare Worker
Link to [application](https://my-worker.wuxinzeng.workers.dev/)


* To redirect the URL, open an terminal and do ` curl https://my-worker.wuxinzeng.workers.dev/ ---verbose`. 
Check that the location has been redirected to https://developers.cloudflare.com/workers/about/.
```
Connection state changed (MAX_CONCURRENT_STREAMS == 256)!
< HTTP/2 302 
< date: Tue, 23 Aug 2022 15:02:41 GMT
< content-length: 0
< location: https://developers.cloudflare.com/workers/about/
```
* To bypass the redirect with a cookie, do ` curl https://my-worker.wuxinzeng.workers.dev/ --cookie "cf-noredir=true"`. You will see "Hello World!"
```
<!DOCTYPE html>
<body>
  <h1>Hello world!</h1>
</body>
```

### Install Workers CLI 
First, I installed the Workers CLI using `npm install -g wrangler`, then I authenitcated to Wrangler with `wrangler login`. I started my new project called my-worker using `wrangler init my-worker`. I used the index.js file in my project directory to implement the logic for URL redirect. 

### Debug Code
To debug the code, I looked into a few things. First I realized that the `User-Agent` in the method `request.headers.get('User-Agent')` was not capitalized. I logged the variable to make sure it returns a correct value for user-agent. Then I looked for the value for the curl user-agent with the -v flag, which returns 'curl/7.64.1'. I also found that the `match` function returns an array of values if the value is there or null if the value is not there by logging the output of the comparison. 
```
let reqUA = request.headers.get('User-Agent');
if (reqUA.match('curl/7.64.1')!=null) { 
    let newLocation = "https://"+newLocationHost+"/workers/about/";
    return Response.redirect(newLocation, 302);
}
return new Response(html, {
    headers: {
        'content-type': 'text/html;charset=UTF-8',
    },
});	
```

### Bypass Redirect
To bypass the redirect if the client request includes a special cookie and value pair, I added an if statement before the redirect logic to check if the cookie from the request header matches the cookie, "cf-noredir=true".
```
	let cookie = request.headers.get('Cookie');
	if (cookie=="cf-noredir=true"){
		return new Response(html, {
			headers: {
			  'content-type': 'text/html;charset=UTF-8',
			},
		});
	}
```
## 6. Lock Down Access to a Path
From the Cloudflare dashboard, I went to Security then Web Application Firewall, where I created a rule that blocks users who use curl to access the path `/nagoyacontact.html`. The full expression for this rule is `(http.request.uri eq "/nagoyacontact.html" and http.user_agent eq "curl/7.64.1")`. I verified that the firewall rule was working as expected in the activity log of the Overview page. 

## Summary 

- Nameservers are the last step in the DNS query. I need to have the correct nameservers before it can find the correct IP addresses. 
- Cloudflare tunnel can protect my origin server by connecting my origin to Cloudflare without a publicly routable IP addres, and I can point DNS records for any hostname in my account.
- Cloudflare is more than a CDN. It specializes in many products with the goal to make the internet more secure.
- Cloudflare's developers docs are great resources to get started on the labs. 
- One issue I ran into was 502 bad gateway when sending a request to the webserver. I set up Cloudflare Tunnel to proxy traffic to this tunnel, and I also created a DNS record to point the hostname to it. I changed the URL and the UUID in the config.yml file. The tunnel is active. However, when I send a request to the URL, I get an error message "host error", but the browser and Cloudflare both look fine. I looked for help from the Cloudflare community, and I knew the issue had to do with my web server. I went to my DNS records and updated the domain to point to the IP address that the domain was initially assigned to, and that fixed my issue.
- Simple descriptions of Cloudflare technologies and their uses: 
    - Cloudflare Web Application Firewall creates rules to protect websites from incoming traffic.
    - Cloudflare DNS maps domains to IP addresses. 
    - Cloudflare Tunnel protects origin servers by mitigating attacks that bypass Cloudflare. It is good for attacks that found these external IP addresses. 
    - Cloudflare Workers is a lightweight tool that helps developers create applications on the fly. It is great for applications that need to scale quickly, i.e. when there is a sudden increase in traffic.
- With Cloudflare, there are additional HTTP response headers. For example, `cf-ray` is a hashed value that provides information of the data center. `cf-cache-status` indicates that the site is using Cloudflare.
- This hands-on exercise gave me a high-level understanding of some of the technologies that Cloudflare provides. In order to implement the solutions, I need to first have a good comprehension of what these technologies do. While working on the exercises, I encountered issues that allowed me to dive deeper into the content. This assessment also leads customers to discover the different aspects of Cloudflare technologies by themselves through answering the questions. For example, I didn't know that Cloudflare already offers a Universal SSL certificate until I explored a bit more on the Cloudflare dashboard. Overall, it is a good lab for someone who wants to try out Cloudflare/learn more about what Cloudflare offers.